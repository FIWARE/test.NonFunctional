This project is part of FIWARE and has been made in collaboration with the TM Forum.

# OpenMTC: non functional test guidelines

OpenMTC is an IoT middleware consisting of gateway and backend functionalities. The gateway hosts protocol adapters that interconnects various devices and decodes device specific information. Additionally local applications can preprocess data before providing them to higher levels. The Backend aggregates information of multiple gateways and provides connection information to the devices. OpenMTC unifies information from heterogeneous data sources by adding semantics and storing the data in a tree based structure. Through the usage of meta information data can be easily discovered. Via oneM2M-based REST APIs and event-based notifications M2M/IoT application developers can easily and dynamically access data from various sensors, without struggling with underlying sensor / actor technology specifics. Interconnection with databases or other frameworks is realized through applications that are mapping local information to specific third-party APIs. The OpenMTC SDK is a tool for IoT application development across multiple verticals and easy integration of devices from different IoT domains. OpenMTC software is written in Python and can be deployed on different hardware platforms (e.g. x86; ARM).

## Testing environment

For the testing environment, is needed:

A machine for the deployment of the GEri to be tested, OpenMTC. We recommend to use the Docker compilation, where you can find everything necessary to run this environment.

A machine for JMeter, the tool used to inject load and for simulating the client and collecting the results generated by OpenMTC.

## Test execution 

### Preliminary setup 

Once the HW necessary for the test described previously at "Testing Environmment" chapter have been setup, the following preliminary steps need to be accomplished before to start the test process: In order to do the installation of OpenMTC, a Docker instance is needed.

## Testing step by step 

The test of OpenMTC must be done in two steps:

*Script configuration:*

Depending on the scenario to execute (stress, stability), number of threads, ramp-up and test duration must be configured. Host IP and Port must be configured. For this purpose, the following User Defined variables in the Jmeter scripts (00_CreateApplicationAndContainers.jmx,01_CreateApplication.jmx,02_CreateContainer.jmx,03_CreatePlainText.jmx,04_GetText.jmx,05_Stability.jmx) must be configured:

- **HOST** -> Host/IP where OpenMTC is desployed.
- **PORT** -> Port in Host where OpenMTC is listening.
- **THREADS** -> Number of threads to run during test.
- **RAMP** -> Time during threads are launched.
- **APLICACION** -> Randomly generated name to be sent in the request. (This variable is automatically generated in runtime)
- **CONTAINER** -> Randomly generated name to be sent in the request. (This variable is automatically generated in runtime)
- **TEXT** -> Randomly generated name to be sent in the request. (This variable is automatically generated in runtime)


It is recommended to use the planificator from the threads group. The duration for the stress tests was 25 minutes, and 6 hours in the stability case.

Finally, in order to get the results, the path to the results file must be configured in the Simple Data Writer from the script.

*Script execution:*

For executing the script, the following command must be typed in the jmeter bin folder:

`./jmeter.sh -n -t /path/to/script/scriptName.jmx`

It´s recommended to execute the command in background and nohup mode:

`nohup ./jmeter.sh -n -t /path/to/script/scriptName.jmx &`

It´s highly recommended to use a hardware resources monitoring tool, in order to measure things like memory and CPU usages, free memory, etc.

## Expected results

As output from the script, a .dat file (in csv format) is generated. This file can be used for plotting different kinds of charts, like threads number, response times, number of errores, responses per second, etc. A plotting tool (like gnuplot) is needed in order to do this.

Additionally, if a monitoring tool has been used, then different data from it is collected too. Depending on the monitoring tool, it can generate charts directly, or it can be used another tool for plotting the output from monitoring tool (for example, sar from systat library can be used for monitoring, and k-sar tool for plotting the sar output)
